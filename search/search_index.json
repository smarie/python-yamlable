{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"yamlable \u00b6 A thin wrapper of PyYaml to convert Python objects to YAML and back. PyYaml is a great library. However it is a bit hard for anyone to add the yaml capability to their classes while keeping control on what's happening. Its YamlObject helper class is a first step but it has two drawbacks: one has to master PyYaml Loader/Dumper internal features to understand what they are doing there is a mandatory metaclass, which can prevent wide adoption (multiple inheritance with metaclasses...) yamlable provides a very easy way for you to leverage PyYaml without seeing the complexity: simply inherit from YamlAble , decorate with @yaml_info , and you're set! You can then optionally override the methods to_yaml_dict and from_yaml_dict to write to / load from a dictionary, so as to adapt the yaml-ability to your class needs. In addition yamlable provides a way to create Yaml codecs for several object types at the same time ( YamlCodec ). Installing \u00b6 > pip install yamlable Usage \u00b6 See the usage examples gallery . Main features / benefits \u00b6 Add yaml-ability to any class easily through inheritance without metaclass (as opposed to YamlObject ) and without knowledge of internal PyYaml loader/dumper logic. Write codecs to support several types at a time and support classes that can't be modified, with YamlCodec Supports loading from mappings, but also sequences and scalars. Dumping is always done as a mapping. Alternate YamlObject2 possibility, inheriting from pyyaml YamlObject . See Also \u00b6 PyYaml documentation Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-yamlable","title":"Home"},{"location":"#yamlable","text":"A thin wrapper of PyYaml to convert Python objects to YAML and back. PyYaml is a great library. However it is a bit hard for anyone to add the yaml capability to their classes while keeping control on what's happening. Its YamlObject helper class is a first step but it has two drawbacks: one has to master PyYaml Loader/Dumper internal features to understand what they are doing there is a mandatory metaclass, which can prevent wide adoption (multiple inheritance with metaclasses...) yamlable provides a very easy way for you to leverage PyYaml without seeing the complexity: simply inherit from YamlAble , decorate with @yaml_info , and you're set! You can then optionally override the methods to_yaml_dict and from_yaml_dict to write to / load from a dictionary, so as to adapt the yaml-ability to your class needs. In addition yamlable provides a way to create Yaml codecs for several object types at the same time ( YamlCodec ).","title":"yamlable"},{"location":"#installing","text":"> pip install yamlable","title":"Installing"},{"location":"#usage","text":"See the usage examples gallery .","title":"Usage"},{"location":"#main-features-benefits","text":"Add yaml-ability to any class easily through inheritance without metaclass (as opposed to YamlObject ) and without knowledge of internal PyYaml loader/dumper logic. Write codecs to support several types at a time and support classes that can't be modified, with YamlCodec Supports loading from mappings, but also sequences and scalars. Dumping is always done as a mapping. Alternate YamlObject2 possibility, inheriting from pyyaml YamlObject .","title":"Main features / benefits"},{"location":"#see-also","text":"PyYaml documentation","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-yamlable","title":"Want to contribute ?"},{"location":"changelog/","text":"Changelog \u00b6 1.1.1 - Python 3.10 compliance \u00b6 Fixed bug with Python 3.10. PR #17 by jfuruness . 1.1.0 - Now load objects from sequences and scalars too \u00b6 Objects (subclasses of YamlAble or YamlObject2 ) can now be loaded from both mappings, sequences and scalars. Users may override the default behaviour by overriding __from_yaml_list__ and __from_yaml_scalar__ . Codecs (subclasses of YamlCodec ) can also support this feature, through the from_yaml_list and from_yaml_scalar methods (not implemented by default). Fixes #12 Now using mkdocs-gallery for documentation examples. Fixed #14 @yaml_info can not be used on subclasses of YamlObject2 anymore as it could lead to an unexpected behaviour. Fixes #15 1.0.4 - better type hinting (mypy) \u00b6 Most type hints have been fixed, in particular for @yaml_info . Fixes #11 . CI/CD pipeline migrated to Github Actions. Added badges using genbadge 1.0.3 - packaging improvements \u00b6 packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #10 1.0.2 - pyproject.toml \u00b6 Added pyproject.toml . 1.0.1 - added __version__ attribute \u00b6 Added __version__ pkg-level attribute. 1.0.0 - Compliance with PyYaml 5.1 and de-facto 1.0.0 \u00b6 this version has been out and stable for long enough to be considered a good 1.0.0 PyYaml 5.1 added some breaking changes. We now comply with them while still supporting the old versions. Fixed #8 . 0.7.1 - minor fix \u00b6 Fixed the file opening mode in dump_yaml method when a file path is provided as argument. 0.7.0 - Abstract class definition and checks have been simplified \u00b6 It should now be easier to define an abstract yaml-able class for several object types. Deprecated NONE_IGNORE_CHECKS . Fixes #7 0.6.0 - YamlAble does not provide a constructor anymore \u00b6 Fixes #6 . 0.5.0 - Python 2.7 support \u00b6 Fixes #5 0.4.0 - YamlCodec completed + dunder methods \u00b6 YamlCodec completed (fixes #4 ): - YamlCodec.decode_yamlable renamed decode and YamlCodec.encode_yamlable renamed encode - added some checks in YamlCodec.encode to help users implement to_yaml_dict correctly - fixed bug in register_with_pyyaml : the wrong decoding method was registered - YamlCodec.create_from_yaml_dict renamed from_yaml_dict for consistency - added tests and usage documentation Renamed internal AbstractYamlObject methods with dunder (fixes #3 ): - from_yaml_dict becomes __from_yaml_dict__ - and to_yaml_dict become __to_yaml_dict__ Legacy names will remain supported for a while, added a tet to check that. 0.3.1 - minor error message improvement \u00b6 Filled yaml_info docstring. fixed class decoding so that it is robust to errors happening with faulty classes. This fixes #2 improved error message when decoding failed. 0.3.0 - safe parameter \u00b6 Added the safe parameter to all dumping and loading methods dump_yaml , dumps_yaml , load_yaml , loads_yaml . 0.2.0 - Added default implementation \u00b6 By default to_yaml_dict returns vars(self) and from_yaml_dict returns cls(**dct) . Fixes #1 0.1.0 - First public version \u00b6 Initial fork from private repository","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#111-python-310-compliance","text":"Fixed bug with Python 3.10. PR #17 by jfuruness .","title":"1.1.1 - Python 3.10 compliance"},{"location":"changelog/#110-now-load-objects-from-sequences-and-scalars-too","text":"Objects (subclasses of YamlAble or YamlObject2 ) can now be loaded from both mappings, sequences and scalars. Users may override the default behaviour by overriding __from_yaml_list__ and __from_yaml_scalar__ . Codecs (subclasses of YamlCodec ) can also support this feature, through the from_yaml_list and from_yaml_scalar methods (not implemented by default). Fixes #12 Now using mkdocs-gallery for documentation examples. Fixed #14 @yaml_info can not be used on subclasses of YamlObject2 anymore as it could lead to an unexpected behaviour. Fixes #15","title":"1.1.0 - Now load objects from sequences and scalars too"},{"location":"changelog/#104-better-type-hinting-mypy","text":"Most type hints have been fixed, in particular for @yaml_info . Fixes #11 . CI/CD pipeline migrated to Github Actions. Added badges using genbadge","title":"1.0.4 - better type hinting (mypy)"},{"location":"changelog/#103-packaging-improvements","text":"packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #10","title":"1.0.3 - packaging improvements"},{"location":"changelog/#102-pyprojecttoml","text":"Added pyproject.toml .","title":"1.0.2 - pyproject.toml"},{"location":"changelog/#101-added-__version__-attribute","text":"Added __version__ pkg-level attribute.","title":"1.0.1 - added __version__ attribute"},{"location":"changelog/#100-compliance-with-pyyaml-51-and-de-facto-100","text":"this version has been out and stable for long enough to be considered a good 1.0.0 PyYaml 5.1 added some breaking changes. We now comply with them while still supporting the old versions. Fixed #8 .","title":"1.0.0 - Compliance with PyYaml 5.1 and de-facto 1.0.0"},{"location":"changelog/#071-minor-fix","text":"Fixed the file opening mode in dump_yaml method when a file path is provided as argument.","title":"0.7.1 - minor fix"},{"location":"changelog/#070-abstract-class-definition-and-checks-have-been-simplified","text":"It should now be easier to define an abstract yaml-able class for several object types. Deprecated NONE_IGNORE_CHECKS . Fixes #7","title":"0.7.0 - Abstract class definition and checks have been simplified"},{"location":"changelog/#060-yamlable-does-not-provide-a-constructor-anymore","text":"Fixes #6 .","title":"0.6.0 - YamlAble does not provide a constructor anymore"},{"location":"changelog/#050-python-27-support","text":"Fixes #5","title":"0.5.0 - Python 2.7 support"},{"location":"changelog/#040-yamlcodec-completed-dunder-methods","text":"YamlCodec completed (fixes #4 ): - YamlCodec.decode_yamlable renamed decode and YamlCodec.encode_yamlable renamed encode - added some checks in YamlCodec.encode to help users implement to_yaml_dict correctly - fixed bug in register_with_pyyaml : the wrong decoding method was registered - YamlCodec.create_from_yaml_dict renamed from_yaml_dict for consistency - added tests and usage documentation Renamed internal AbstractYamlObject methods with dunder (fixes #3 ): - from_yaml_dict becomes __from_yaml_dict__ - and to_yaml_dict become __to_yaml_dict__ Legacy names will remain supported for a while, added a tet to check that.","title":"0.4.0 - YamlCodec completed + dunder methods"},{"location":"changelog/#031-minor-error-message-improvement","text":"Filled yaml_info docstring. fixed class decoding so that it is robust to errors happening with faulty classes. This fixes #2 improved error message when decoding failed.","title":"0.3.1 - minor error message improvement"},{"location":"changelog/#030-safe-parameter","text":"Added the safe parameter to all dumping and loading methods dump_yaml , dumps_yaml , load_yaml , loads_yaml .","title":"0.3.0 - safe parameter"},{"location":"changelog/#020-added-default-implementation","text":"By default to_yaml_dict returns vars(self) and from_yaml_dict returns cls(**dct) . Fixes #1","title":"0.2.0 - Added default implementation"},{"location":"changelog/#010-first-public-version","text":"Initial fork from private repository","title":"0.1.0 - First public version"},{"location":"long_description/","text":"yamlable \u00b6 A thin wrapper of PyYaml to convert Python objects to YAML and back. The documentation for users is available here: https://smarie.github.io/python-yamlable/ A readme for developers is available here: https://github.com/smarie/python-yamlable","title":"yamlable"},{"location":"long_description/#yamlable","text":"A thin wrapper of PyYaml to convert Python objects to YAML and back. The documentation for users is available here: https://smarie.github.io/python-yamlable/ A readme for developers is available here: https://github.com/smarie/python-yamlable","title":"yamlable"},{"location":"generated/gallery/","text":"Usage examples \u00b6 These examples demonstrate how to use the library. Yaml-able classes Writing Codecs Download all examples in Python source code: gallery_python.zip Download all examples in Jupyter notebooks: gallery_jupyter.zip Gallery generated by mkdocs-gallery","title":"Usage examples"},{"location":"generated/gallery/#usage-examples","text":"These examples demonstrate how to use the library. Yaml-able classes Writing Codecs Download all examples in Python source code: gallery_python.zip Download all examples in Jupyter notebooks: gallery_jupyter.zip Gallery generated by mkdocs-gallery","title":"Usage examples"},{"location":"generated/gallery/1_basic_usage_demo/","text":"Note Click here to download the full example code Yaml-able classes \u00b6 Let's make a class yaml-aware so that instances can be loaded from YAML and dumped to YAML. 1. Basics \u00b6 To make a class yaml-able, we have to inherit from YamlAble decorate it with the @yaml_info annotation to declare the associated yaml tag from yamlable import yaml_info , YamlAble @yaml_info ( yaml_tag_ns = 'com.yamlable.example' ) class Foo ( YamlAble ): def __init__ ( self , a , b = \"hey\" ): \"\"\" Constructor \"\"\" self . a = a self . b = b def __repr__ ( self ): \"\"\" String representation for prints \"\"\" return f \" { type ( self ) . __name__ } - { dict ( a = self . a , b = self . b ) } \" That's it! Let's check that our class is correct and allows us to create instances: f = Foo ( 1 , 'hello' ) f Out: Foo - { 'a' : 1 , 'b' : 'hello' } Now let's dump it to a YAML document using pyyaml : import yaml print ( yaml . dump ( f )) Out: !yamlable/com.yamlable.example.Foo a: 1 b: hello we can also load an instance from a document: f2 = yaml . safe_load ( \"\"\" !yamlable/com.yamlable.example.Foo a: 0 b: hey \"\"\" ) print ( f2 ) Out: Foo - { 'a' : 0 , 'b' : 'hey' } For more general cases where your object is embedded in a more complex structure for example, it will work as expected: d = { 'foo' : f , 'foo2' : 12 } print ( yaml . dump ( d )) Out: foo: !yamlable/com.yamlable.example.Foo a: 1 b: hello foo2: 12 In addition, the object directly offers the dump_yaml (dumping to file) / dumps_yaml (dumping to string) convenience methods, and the class directly offers the load_yaml (load from file) / loads_yaml (load from string) convenience methods. See PyYaml documentation for the various formatting arguments that you can use, they are the same than in the yaml.dump method. For example: print ( f . dumps_yaml ( default_flow_style = False )) Out: !yamlable/com.yamlable.example.Foo a: 1 b: hello 2. Customization \u00b6 a. dumper/loader \u00b6 As could be seen above, YamlAble comes with a default implementation of the yaml formatting and parsing associated with the classes. This is controlled by two methods that you may wish to override: __to_yaml_dict__ is an instance method that controls what to dump. By default it returns vars(self) __from_yaml_dict__ is a class method that controls the loading process. By default it returns cls(**dct) . You may wish to override one, or both of these methods. For example if you do not wish to dump all of the object attributes: @yaml_info ( yaml_tag_ns = 'com.yamlable.example' ) class CustomFoo ( YamlAble ): def __init__ ( self , a , b ): \"\"\" Constructor \"\"\" self . a = a self . b = b self . irrelevant = 37 def __repr__ ( self ): \"\"\" String representation for prints \"\"\" return f \" { type ( self ) . __name__ } - { dict ( a = self . a , b = self . b , irrelevant = self . irrelevant ) } \" def __to_yaml_dict__ ( self ): # Do not dump 'irrelevant' return { 'a' : self . a , 'b' : self . b } @classmethod def __from_yaml_dict__ ( cls , dct , yaml_tag ): # Accept a default value for b return cls ( dct [ 'a' ], dct . get ( 'b' , \"default\" )) Let's test it: loading... f3 = yaml . safe_load ( \"\"\" !yamlable/com.yamlable.example.CustomFoo a: 0 \"\"\" ) print ( f3 ) Out: CustomFoo - { 'a' : 0 , 'b' : 'default' , 'irrelevant' : 37 } ...and dumping again print ( f3 . dumps_yaml ()) Out: !yamlable/com.yamlable.example.CustomFoo a: 0 b: default b. YAML tag \u00b6 You probably noticed in the above examples that the dumped YAML document contains a tag such as !yamlable/com.yamlable.example.CustomFoo . When you dump a YamlAble object o to yaml, the corresponding tag is f!yamlable/{o.__yaml_tag_suffix__} . Note that you can override the class attribute, or even the instance attribute: f3 . __yaml_tag_suffix__ = \"wow_you_changed_me\" print ( f3 . dumps_yaml ()) Out: !yamlable/wow_you_changed_me a: 0 b: default The @yaml_info decorator is just a convenient way to fill the __yaml_tag_suffix__ attribute on a class, nothing more. You can either provide a full yaml tag suffix: @yaml_info ( \"com.example.WowObject\" ) class MyFoo ( YamlAble ): pass print ( MyFoo . __yaml_tag_suffix__ ) print ( MyFoo () . dumps_yaml ()) Out: com.example.WowObject !yamlable/com.example.WowObject {} Notice that this is great for retrocompatiblity: you can change your class name or module without changing the YAML serialization. Otherwise you can simply provide a namespace, that will be appended with .{cls.__name__} : @yaml_info ( yaml_tag_ns = \"com.example\" ) class MyFoo ( YamlAble ): pass print ( MyFoo . __yaml_tag_suffix__ ) print ( MyFoo () . dumps_yaml ()) Out: com.example.MyFoo !yamlable/com.example.MyFoo {} In that case, you'll have to be sure that your class name does not change over time. If you do not like the !yamlable prefix, you should use the alternate YamlObject2 class - in that case the decorator should not be used. 3. Alternate way: YamlObject2 \u00b6 If you absolutely wish to use PyYaml's YamlObject for some reason, you can use YamlObject2 as an alternative to YamlAble . But it comes with the metaclass, like YamlObject . Nevertheless, the way to work is very similar: simply override the optional methods. However you must specify the entire yaml tag directly using the yaml_tag class variable. The @yaml_info decorator can not be used with classes subclassing YamlObject2 . from yamlable import YamlObject2 class CustomFoo2 ( YamlObject2 ): yaml_tag = '!foo' def __init__ ( self , a , b ): \"\"\" Constructor \"\"\" self . a = a self . b = b self . irrelevant = 37 def __repr__ ( self ): \"\"\" String representation for prints \"\"\" return f \" { type ( self ) . __name__ } - { dict ( a = self . a , b = self . b , irrelevant = self . irrelevant ) } \" def __to_yaml_dict__ ( self ): # Do not dump 'irrelevant' return { 'a' : self . a , 'b' : self . b } @classmethod def __from_yaml_dict__ ( cls , dct , yaml_tag ): # Accept a default value for b return cls ( dct [ 'a' ], dct . get ( 'b' , \"default\" )) # instantiate f = CustomFoo2 ( 1 , 'hello' ) # dump to yaml o = yaml . dump ( f ) print ( o ) print ( yaml . safe_load ( o )) Out: !foo a: 1 b: hello CustomFoo2 - { 'a' : 1 , 'b' : 'hello' , 'irrelevant' : 37 } 4. Support for sequences and scalars \u00b6 Objects can also be loaded from YAML sequences: yaml . safe_load ( \"\"\" !yamlable/com.yamlable.example.Foo - 0 - hey \"\"\" ) Out: Foo - { 'a' : 0 , 'b' : 'hey' } The default implementation of __from_yaml_list__ (that you may wish to override in your subclass), is to call the constructor with the sequence contents as positional arguments. The same also works for scalars: yaml . safe_load ( \"\"\" !yamlable/com.yamlable.example.Foo 0 \"\"\" ) Out: Foo - { 'a' : '0' , 'b' : 'hey' } The default implementation of __from_yaml_scalar__ (that you may wish to override in your subclass), is to call the constructor with the scalar as first positional argument. Scalars are not resolved As can be seen in the above example, scalars are not auto-resolved when constructing an object from a scalar. So an integer 0 is actually received as a string \"0\" by from_yaml_scalar . Total running time of the script: ( 0 minutes 0.014 seconds) Download Python source code: 1_basic_usage_demo.py Download Jupyter notebook: 1_basic_usage_demo.ipynb Gallery generated by mkdocs-gallery","title":"Yaml-able classes"},{"location":"generated/gallery/1_basic_usage_demo/#yaml-able-classes","text":"Let's make a class yaml-aware so that instances can be loaded from YAML and dumped to YAML.","title":"Yaml-able classes"},{"location":"generated/gallery/1_basic_usage_demo/#1-basics","text":"To make a class yaml-able, we have to inherit from YamlAble decorate it with the @yaml_info annotation to declare the associated yaml tag from yamlable import yaml_info , YamlAble @yaml_info ( yaml_tag_ns = 'com.yamlable.example' ) class Foo ( YamlAble ): def __init__ ( self , a , b = \"hey\" ): \"\"\" Constructor \"\"\" self . a = a self . b = b def __repr__ ( self ): \"\"\" String representation for prints \"\"\" return f \" { type ( self ) . __name__ } - { dict ( a = self . a , b = self . b ) } \" That's it! Let's check that our class is correct and allows us to create instances: f = Foo ( 1 , 'hello' ) f Out: Foo - { 'a' : 1 , 'b' : 'hello' } Now let's dump it to a YAML document using pyyaml : import yaml print ( yaml . dump ( f )) Out: !yamlable/com.yamlable.example.Foo a: 1 b: hello we can also load an instance from a document: f2 = yaml . safe_load ( \"\"\" !yamlable/com.yamlable.example.Foo a: 0 b: hey \"\"\" ) print ( f2 ) Out: Foo - { 'a' : 0 , 'b' : 'hey' } For more general cases where your object is embedded in a more complex structure for example, it will work as expected: d = { 'foo' : f , 'foo2' : 12 } print ( yaml . dump ( d )) Out: foo: !yamlable/com.yamlable.example.Foo a: 1 b: hello foo2: 12 In addition, the object directly offers the dump_yaml (dumping to file) / dumps_yaml (dumping to string) convenience methods, and the class directly offers the load_yaml (load from file) / loads_yaml (load from string) convenience methods. See PyYaml documentation for the various formatting arguments that you can use, they are the same than in the yaml.dump method. For example: print ( f . dumps_yaml ( default_flow_style = False )) Out: !yamlable/com.yamlable.example.Foo a: 1 b: hello","title":"1. Basics"},{"location":"generated/gallery/1_basic_usage_demo/#2-customization","text":"","title":"2. Customization"},{"location":"generated/gallery/1_basic_usage_demo/#a-dumperloader","text":"As could be seen above, YamlAble comes with a default implementation of the yaml formatting and parsing associated with the classes. This is controlled by two methods that you may wish to override: __to_yaml_dict__ is an instance method that controls what to dump. By default it returns vars(self) __from_yaml_dict__ is a class method that controls the loading process. By default it returns cls(**dct) . You may wish to override one, or both of these methods. For example if you do not wish to dump all of the object attributes: @yaml_info ( yaml_tag_ns = 'com.yamlable.example' ) class CustomFoo ( YamlAble ): def __init__ ( self , a , b ): \"\"\" Constructor \"\"\" self . a = a self . b = b self . irrelevant = 37 def __repr__ ( self ): \"\"\" String representation for prints \"\"\" return f \" { type ( self ) . __name__ } - { dict ( a = self . a , b = self . b , irrelevant = self . irrelevant ) } \" def __to_yaml_dict__ ( self ): # Do not dump 'irrelevant' return { 'a' : self . a , 'b' : self . b } @classmethod def __from_yaml_dict__ ( cls , dct , yaml_tag ): # Accept a default value for b return cls ( dct [ 'a' ], dct . get ( 'b' , \"default\" )) Let's test it: loading... f3 = yaml . safe_load ( \"\"\" !yamlable/com.yamlable.example.CustomFoo a: 0 \"\"\" ) print ( f3 ) Out: CustomFoo - { 'a' : 0 , 'b' : 'default' , 'irrelevant' : 37 } ...and dumping again print ( f3 . dumps_yaml ()) Out: !yamlable/com.yamlable.example.CustomFoo a: 0 b: default","title":"a. dumper/loader"},{"location":"generated/gallery/1_basic_usage_demo/#b-yaml-tag","text":"You probably noticed in the above examples that the dumped YAML document contains a tag such as !yamlable/com.yamlable.example.CustomFoo . When you dump a YamlAble object o to yaml, the corresponding tag is f!yamlable/{o.__yaml_tag_suffix__} . Note that you can override the class attribute, or even the instance attribute: f3 . __yaml_tag_suffix__ = \"wow_you_changed_me\" print ( f3 . dumps_yaml ()) Out: !yamlable/wow_you_changed_me a: 0 b: default The @yaml_info decorator is just a convenient way to fill the __yaml_tag_suffix__ attribute on a class, nothing more. You can either provide a full yaml tag suffix: @yaml_info ( \"com.example.WowObject\" ) class MyFoo ( YamlAble ): pass print ( MyFoo . __yaml_tag_suffix__ ) print ( MyFoo () . dumps_yaml ()) Out: com.example.WowObject !yamlable/com.example.WowObject {} Notice that this is great for retrocompatiblity: you can change your class name or module without changing the YAML serialization. Otherwise you can simply provide a namespace, that will be appended with .{cls.__name__} : @yaml_info ( yaml_tag_ns = \"com.example\" ) class MyFoo ( YamlAble ): pass print ( MyFoo . __yaml_tag_suffix__ ) print ( MyFoo () . dumps_yaml ()) Out: com.example.MyFoo !yamlable/com.example.MyFoo {} In that case, you'll have to be sure that your class name does not change over time. If you do not like the !yamlable prefix, you should use the alternate YamlObject2 class - in that case the decorator should not be used.","title":"b. YAML tag"},{"location":"generated/gallery/1_basic_usage_demo/#3-alternate-way-yamlobject2","text":"If you absolutely wish to use PyYaml's YamlObject for some reason, you can use YamlObject2 as an alternative to YamlAble . But it comes with the metaclass, like YamlObject . Nevertheless, the way to work is very similar: simply override the optional methods. However you must specify the entire yaml tag directly using the yaml_tag class variable. The @yaml_info decorator can not be used with classes subclassing YamlObject2 . from yamlable import YamlObject2 class CustomFoo2 ( YamlObject2 ): yaml_tag = '!foo' def __init__ ( self , a , b ): \"\"\" Constructor \"\"\" self . a = a self . b = b self . irrelevant = 37 def __repr__ ( self ): \"\"\" String representation for prints \"\"\" return f \" { type ( self ) . __name__ } - { dict ( a = self . a , b = self . b , irrelevant = self . irrelevant ) } \" def __to_yaml_dict__ ( self ): # Do not dump 'irrelevant' return { 'a' : self . a , 'b' : self . b } @classmethod def __from_yaml_dict__ ( cls , dct , yaml_tag ): # Accept a default value for b return cls ( dct [ 'a' ], dct . get ( 'b' , \"default\" )) # instantiate f = CustomFoo2 ( 1 , 'hello' ) # dump to yaml o = yaml . dump ( f ) print ( o ) print ( yaml . safe_load ( o )) Out: !foo a: 1 b: hello CustomFoo2 - { 'a' : 1 , 'b' : 'hello' , 'irrelevant' : 37 }","title":"3. Alternate way: YamlObject2"},{"location":"generated/gallery/1_basic_usage_demo/#4-support-for-sequences-and-scalars","text":"Objects can also be loaded from YAML sequences: yaml . safe_load ( \"\"\" !yamlable/com.yamlable.example.Foo - 0 - hey \"\"\" ) Out: Foo - { 'a' : 0 , 'b' : 'hey' } The default implementation of __from_yaml_list__ (that you may wish to override in your subclass), is to call the constructor with the sequence contents as positional arguments. The same also works for scalars: yaml . safe_load ( \"\"\" !yamlable/com.yamlable.example.Foo 0 \"\"\" ) Out: Foo - { 'a' : '0' , 'b' : 'hey' } The default implementation of __from_yaml_scalar__ (that you may wish to override in your subclass), is to call the constructor with the scalar as first positional argument. Scalars are not resolved As can be seen in the above example, scalars are not auto-resolved when constructing an object from a scalar. So an integer 0 is actually received as a string \"0\" by from_yaml_scalar . Total running time of the script: ( 0 minutes 0.014 seconds) Download Python source code: 1_basic_usage_demo.py Download Jupyter notebook: 1_basic_usage_demo.ipynb Gallery generated by mkdocs-gallery","title":"4. Support for sequences and scalars"},{"location":"generated/gallery/2_codecs_demo/","text":"Note Click here to download the full example code Writing Codecs \u00b6 Handle Yaml-ability for several classes at once, without modifying them. What if you can not modify the class and still would like to make it yaml-able ? For such a (frequent) situation yamlable provides another possibility: writing so-called \"codecs\". A codec is a subclass of YamlCodec that will handle several classes at once, typically classes that you cannot modify. 1. Writing a codec class \u00b6 Sometimes you do not have the possibility to change the classes of the objects that you wish to encode/decode. In this case the solution is to write an independent codec, inheriting from YamlCodec . Once again this feature leverages the multi_constructor and multi_representer concepts available in the PyYaml internals, but with YamlCodec it becomes a bit easier to do. Let's assume that the following two classes are given and can not be modified: class Foo : def __init__ ( self , a , b ): self . a = a self . b = b def __eq__ ( self , other ): return vars ( self ) == vars ( other ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } - { vars ( self ) } \" class Bar : def __init__ ( self , c ): self . c = c def __eq__ ( self , other ): return vars ( self ) == vars ( other ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } - { vars ( self ) } \" Writing a codec is quite simple: first inherit from YamlCodec and fill get_yaml_prefix so that it returns the common prefix that all yaml objects encoded/decoded by this codec will use then fill the checkers: get_known_types to return all object types that can be encoded by this codec is_yaml_tag_supported to return True if a yaml tag (suffix) is supported by this codec for decoding. finally fill the encoder/decoder: from_yaml_dict to decode. As opposed to the single class example , this method also receives the tag so as to load the right object type. to_yaml_dict to encode. As opposed to the single class example , this method should return a tuple with (yaml_tag, dict) so that different objects can be dumped as different yaml tags. The example below shows how it can be done: from yamlable import YamlCodec from typing import Type , Any , Iterable , Tuple # the yaml tag suffixes for the two classes foo_yaml = \"yaml.tests.Foo\" bar_yaml = \"yaml.tests.Bar\" # 2-way mappings between the types and the yaml tags types_to_yaml_tags = { Foo : foo_yaml , Bar : bar_yaml } yaml_tags_to_types = { foo_yaml : Foo , bar_yaml : Bar } class MyCodec ( YamlCodec ): @classmethod def get_yaml_prefix ( cls ): return \"!mycodec/\" # This is our root yaml tag # ---- @classmethod def get_known_types ( cls ) -> Iterable [ Type [ Any ]]: # return the list of types that we know how to encode return types_to_yaml_tags . keys () @classmethod def is_yaml_tag_supported ( cls , yaml_tag_suffix : str ) -> bool : # return True if the given yaml tag suffix is supported return yaml_tag_suffix in yaml_tags_to_types . keys () # ---- @classmethod def from_yaml_dict ( cls , yaml_tag_suffix : str , dct , ** kwargs ): # Create an object corresponding to the given tag, from the decoded dict typ = yaml_tags_to_types [ yaml_tag_suffix ] return typ ( ** dct ) @classmethod def to_yaml_dict ( cls , obj ) -> Tuple [ str , Any ]: # Encode the given object and also return the tag that it should have return types_to_yaml_tags [ type ( obj )], vars ( obj ) 2. Registering a codec \u00b6 When you codec has been defined, it needs to be registered before being usable. You can specify with which PyYaml Loaders/Dumpers it should be registered, or use the default (all): # register the codec MyCodec . register_with_pyyaml () 3. Using a codec \u00b6 Finally let's test that the codec works: from yaml import dump , safe_load # instantiate f = Foo ( 1 , 'hello' ) print ( dump ( f )) b = Bar ( 'what?' ) print ( dump ( b )) Out: !mycodec/yaml.tests.Foo a: 1 b: hello !mycodec/yaml.tests.Bar c: what? # load fy = \"!mycodec/yaml.tests.Foo {a: 1, b: hello} \\n \" print ( safe_load ( fy )) by = \"!mycodec/yaml.tests.Bar {c: 'what?'} \\n \" print ( safe_load ( by )) Out: Foo - { 'a' : 1 , 'b' : 'hello' } Bar - { 'c' : 'what?' } 4. Sequences and scalars \u00b6 Objects can be loaded from sequences and scalars, in addition to dictionaries. To support this possibility, you simply need to fill the class methods: from_yaml_list for sequences from_yaml_scalar for scalars class MyCodec2 ( MyCodec ): @classmethod def from_yaml_list ( cls , yaml_tag_suffix , seq , ** kwargs ): typ = yaml_tags_to_types [ yaml_tag_suffix ] return typ ( * seq ) @classmethod def from_yaml_scalar ( cls , yaml_tag_suffix , scalar , ** kwargs ): typ = yaml_tags_to_types [ yaml_tag_suffix ] return typ ( scalar ) # register the codec MyCodec2 . register_with_pyyaml () Then loading from sequence works by_seq = \"\"\"!mycodec/yaml.tests.Bar - what? \"\"\" safe_load ( by_seq ) Out: Bar - { 'c' : 'what?' } As well as scalar by_scalar = \"!mycodec/yaml.tests.Bar what?\" safe_load ( by_scalar ) Out: Bar - { 'c' : 'what?' } Total running time of the script: ( 0 minutes 0.006 seconds) Download Python source code: 2_codecs_demo.py Download Jupyter notebook: 2_codecs_demo.ipynb Gallery generated by mkdocs-gallery","title":"Writing Codecs"},{"location":"generated/gallery/2_codecs_demo/#writing-codecs","text":"Handle Yaml-ability for several classes at once, without modifying them. What if you can not modify the class and still would like to make it yaml-able ? For such a (frequent) situation yamlable provides another possibility: writing so-called \"codecs\". A codec is a subclass of YamlCodec that will handle several classes at once, typically classes that you cannot modify.","title":"Writing Codecs"},{"location":"generated/gallery/2_codecs_demo/#1-writing-a-codec-class","text":"Sometimes you do not have the possibility to change the classes of the objects that you wish to encode/decode. In this case the solution is to write an independent codec, inheriting from YamlCodec . Once again this feature leverages the multi_constructor and multi_representer concepts available in the PyYaml internals, but with YamlCodec it becomes a bit easier to do. Let's assume that the following two classes are given and can not be modified: class Foo : def __init__ ( self , a , b ): self . a = a self . b = b def __eq__ ( self , other ): return vars ( self ) == vars ( other ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } - { vars ( self ) } \" class Bar : def __init__ ( self , c ): self . c = c def __eq__ ( self , other ): return vars ( self ) == vars ( other ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } - { vars ( self ) } \" Writing a codec is quite simple: first inherit from YamlCodec and fill get_yaml_prefix so that it returns the common prefix that all yaml objects encoded/decoded by this codec will use then fill the checkers: get_known_types to return all object types that can be encoded by this codec is_yaml_tag_supported to return True if a yaml tag (suffix) is supported by this codec for decoding. finally fill the encoder/decoder: from_yaml_dict to decode. As opposed to the single class example , this method also receives the tag so as to load the right object type. to_yaml_dict to encode. As opposed to the single class example , this method should return a tuple with (yaml_tag, dict) so that different objects can be dumped as different yaml tags. The example below shows how it can be done: from yamlable import YamlCodec from typing import Type , Any , Iterable , Tuple # the yaml tag suffixes for the two classes foo_yaml = \"yaml.tests.Foo\" bar_yaml = \"yaml.tests.Bar\" # 2-way mappings between the types and the yaml tags types_to_yaml_tags = { Foo : foo_yaml , Bar : bar_yaml } yaml_tags_to_types = { foo_yaml : Foo , bar_yaml : Bar } class MyCodec ( YamlCodec ): @classmethod def get_yaml_prefix ( cls ): return \"!mycodec/\" # This is our root yaml tag # ---- @classmethod def get_known_types ( cls ) -> Iterable [ Type [ Any ]]: # return the list of types that we know how to encode return types_to_yaml_tags . keys () @classmethod def is_yaml_tag_supported ( cls , yaml_tag_suffix : str ) -> bool : # return True if the given yaml tag suffix is supported return yaml_tag_suffix in yaml_tags_to_types . keys () # ---- @classmethod def from_yaml_dict ( cls , yaml_tag_suffix : str , dct , ** kwargs ): # Create an object corresponding to the given tag, from the decoded dict typ = yaml_tags_to_types [ yaml_tag_suffix ] return typ ( ** dct ) @classmethod def to_yaml_dict ( cls , obj ) -> Tuple [ str , Any ]: # Encode the given object and also return the tag that it should have return types_to_yaml_tags [ type ( obj )], vars ( obj )","title":"1. Writing a codec class"},{"location":"generated/gallery/2_codecs_demo/#2-registering-a-codec","text":"When you codec has been defined, it needs to be registered before being usable. You can specify with which PyYaml Loaders/Dumpers it should be registered, or use the default (all): # register the codec MyCodec . register_with_pyyaml ()","title":"2. Registering a codec"},{"location":"generated/gallery/2_codecs_demo/#3-using-a-codec","text":"Finally let's test that the codec works: from yaml import dump , safe_load # instantiate f = Foo ( 1 , 'hello' ) print ( dump ( f )) b = Bar ( 'what?' ) print ( dump ( b )) Out: !mycodec/yaml.tests.Foo a: 1 b: hello !mycodec/yaml.tests.Bar c: what? # load fy = \"!mycodec/yaml.tests.Foo {a: 1, b: hello} \\n \" print ( safe_load ( fy )) by = \"!mycodec/yaml.tests.Bar {c: 'what?'} \\n \" print ( safe_load ( by )) Out: Foo - { 'a' : 1 , 'b' : 'hello' } Bar - { 'c' : 'what?' }","title":"3. Using a codec"},{"location":"generated/gallery/2_codecs_demo/#4-sequences-and-scalars","text":"Objects can be loaded from sequences and scalars, in addition to dictionaries. To support this possibility, you simply need to fill the class methods: from_yaml_list for sequences from_yaml_scalar for scalars class MyCodec2 ( MyCodec ): @classmethod def from_yaml_list ( cls , yaml_tag_suffix , seq , ** kwargs ): typ = yaml_tags_to_types [ yaml_tag_suffix ] return typ ( * seq ) @classmethod def from_yaml_scalar ( cls , yaml_tag_suffix , scalar , ** kwargs ): typ = yaml_tags_to_types [ yaml_tag_suffix ] return typ ( scalar ) # register the codec MyCodec2 . register_with_pyyaml () Then loading from sequence works by_seq = \"\"\"!mycodec/yaml.tests.Bar - what? \"\"\" safe_load ( by_seq ) Out: Bar - { 'c' : 'what?' } As well as scalar by_scalar = \"!mycodec/yaml.tests.Bar what?\" safe_load ( by_scalar ) Out: Bar - { 'c' : 'what?' } Total running time of the script: ( 0 minutes 0.006 seconds) Download Python source code: 2_codecs_demo.py Download Jupyter notebook: 2_codecs_demo.ipynb Gallery generated by mkdocs-gallery","title":"4. Sequences and scalars"},{"location":"generated/gallery/mg_execution_times/","text":"Computation times \u00b6 00:00.020 total execution time for generated_gallery files: +-------------------------------------------------------------------------------------+-----------+--------+ | 1_basic_usage_demo (docs/examples/1_basic_usage_demo.py) | 00:00.014 | 0.0 MB | +-------------------------------------------------------------------------------------+-----------+--------+ | 2_codecs_demo (docs/examples/2_codecs_demo.py) | 00:00.006 | 0.0 MB | +-------------------------------------------------------------------------------------+-----------+--------+","title":"Computation times"},{"location":"generated/gallery/mg_execution_times/#computation-times","text":"00:00.020 total execution time for generated_gallery files: +-------------------------------------------------------------------------------------+-----------+--------+ | 1_basic_usage_demo (docs/examples/1_basic_usage_demo.py) | 00:00.014 | 0.0 MB | +-------------------------------------------------------------------------------------+-----------+--------+ | 2_codecs_demo (docs/examples/2_codecs_demo.py) | 00:00.006 | 0.0 MB | +-------------------------------------------------------------------------------------+-----------+--------+","title":"Computation times"}]}