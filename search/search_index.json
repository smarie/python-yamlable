{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"yamlable \u00b6 A thin wrapper of PyYaml to convert Python objects to YAML and back. PyYaml is a great library. However it is a bit hard for anyone to add the yaml capability to their classes while keeping control on what's happening. Its YamlObject helper class is a first step but it has two drawbacks: one has to master PyYaml Loader/Dumper internal features to understand what they are doing there is a mandatory metaclass, which can prevent wide adoption (multiple inheritance with metaclasses...) yamlable provides a very easy way for you to leverage PyYaml without seeing the complexity: simply inherit from YamlAble , decorate with @yaml_info , and you're set! You can then optionally override the methods to_yaml_dict and from_yaml_dict to write to / load from a dictionary, so as to adapt the yaml-ability to your class needs. In addition yamlable provides a way to create Yaml codecs for several object types at the same time ( YamlCodec ) (see Usage page) Installing \u00b6 > pip install yamlable Usage \u00b6 Let's make a class yaml-able: we have to inherit from YamlAble decorate it with the @yaml_info annotation to declare the associated yaml tag optionally implement __from_yaml_dict__ (class method called during decoding) and/or __to_yaml_dict__ (instance method called during encoding) if we wish to have control on the process, for example to only dump part of the attributes or perform some custom instance creation. Note that default implementation relies on vars(self) for dumping and on cls(**dct) for loading. from yamlable import yaml_info , YamlAble @yaml_info ( yaml_tag_ns = 'com.yamlable.example' ) class Foo ( YamlAble ): def __init__ ( self , a , b ): \"\"\" Constructor \"\"\" self . a = a self . b = b self . irrelevant = 37 def __str__ ( self ): \"\"\" String representation for prints \"\"\" return \"Foo - \" + str ( dict ( a = self . a , b = self . b )) def __to_yaml_dict__ ( self ): \"\"\" This optional method is called when you call yaml.dump()\"\"\" return { 'a' : self . a , 'b' : self . b } @classmethod def __from_yaml_dict__ ( cls , dct , yaml_tag ): \"\"\" This optional method is called when you call yaml.load()\"\"\" return Foo ( dct [ 'a' ], dct [ 'b' ]) That's it! Let's check that our class is correct and allows us to create instances: >>> f = Foo ( 1 , 'hello' ) >>> print ( f ) Foo - { 'a' : 1 , 'b' : 'hello' } Now let's dump and load it using pyyaml : >>> import yaml >>> print ( yaml . dump ( f )) ! yamlable / com . yamlable . example . Foo { a : 1 , b : hello } >>> print ( yaml . safe_load ( \"!yamlable/com.yamlable.example.Foo {a: 0, b: hey}\" )) Foo - { 'a' : 0 , 'b' : 'hey' } For more general cases where your object is embedded in a more complex structure for example, it will work as expected: >>> d = { 'foo' : f , 'foo2' : 12 } >>> print ( yaml . safe_dump ( d )) foo : ! yamlable / com . yamlable . example . Foo { a : 1 , b : hello } foo2 : 12 In addition, the object directly offers the dump_yaml (dumping to file) / dumps_yaml (dumping to string) convenience methods, and the class directly offers the load_yaml (load from file) / loads_yaml (load from string) convenience methods. See PyYaml documentation for the various formatting arguments that you can use, they are the same than in the yaml.dump method. For example: >>> print ( f . dumps_yaml ( default_flow_style = False )) ! yamlable / com . yamlable . example . Foo a : 1 b : hello See Usage for other possibilities of yamlable . Main features / benefits \u00b6 Add yaml-ability to any class easily through inheritance without metaclass (as opposed to YamlObject ) and without knowledge of internal PyYaml loader/dumper logic. Write codecs to support several types at a time with YamlCodec If you absolutely wish to use PyYaml's YamlObject for some reason, you can use YamlObject2 as an alternative to YamlAble . But it comes with the metaclass, like YamlObject . See Also \u00b6 PyYaml documentation Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-yamlable","title":"Home"},{"location":"#yamlable","text":"A thin wrapper of PyYaml to convert Python objects to YAML and back. PyYaml is a great library. However it is a bit hard for anyone to add the yaml capability to their classes while keeping control on what's happening. Its YamlObject helper class is a first step but it has two drawbacks: one has to master PyYaml Loader/Dumper internal features to understand what they are doing there is a mandatory metaclass, which can prevent wide adoption (multiple inheritance with metaclasses...) yamlable provides a very easy way for you to leverage PyYaml without seeing the complexity: simply inherit from YamlAble , decorate with @yaml_info , and you're set! You can then optionally override the methods to_yaml_dict and from_yaml_dict to write to / load from a dictionary, so as to adapt the yaml-ability to your class needs. In addition yamlable provides a way to create Yaml codecs for several object types at the same time ( YamlCodec ) (see Usage page)","title":"yamlable"},{"location":"#installing","text":"> pip install yamlable","title":"Installing"},{"location":"#usage","text":"Let's make a class yaml-able: we have to inherit from YamlAble decorate it with the @yaml_info annotation to declare the associated yaml tag optionally implement __from_yaml_dict__ (class method called during decoding) and/or __to_yaml_dict__ (instance method called during encoding) if we wish to have control on the process, for example to only dump part of the attributes or perform some custom instance creation. Note that default implementation relies on vars(self) for dumping and on cls(**dct) for loading. from yamlable import yaml_info , YamlAble @yaml_info ( yaml_tag_ns = 'com.yamlable.example' ) class Foo ( YamlAble ): def __init__ ( self , a , b ): \"\"\" Constructor \"\"\" self . a = a self . b = b self . irrelevant = 37 def __str__ ( self ): \"\"\" String representation for prints \"\"\" return \"Foo - \" + str ( dict ( a = self . a , b = self . b )) def __to_yaml_dict__ ( self ): \"\"\" This optional method is called when you call yaml.dump()\"\"\" return { 'a' : self . a , 'b' : self . b } @classmethod def __from_yaml_dict__ ( cls , dct , yaml_tag ): \"\"\" This optional method is called when you call yaml.load()\"\"\" return Foo ( dct [ 'a' ], dct [ 'b' ]) That's it! Let's check that our class is correct and allows us to create instances: >>> f = Foo ( 1 , 'hello' ) >>> print ( f ) Foo - { 'a' : 1 , 'b' : 'hello' } Now let's dump and load it using pyyaml : >>> import yaml >>> print ( yaml . dump ( f )) ! yamlable / com . yamlable . example . Foo { a : 1 , b : hello } >>> print ( yaml . safe_load ( \"!yamlable/com.yamlable.example.Foo {a: 0, b: hey}\" )) Foo - { 'a' : 0 , 'b' : 'hey' } For more general cases where your object is embedded in a more complex structure for example, it will work as expected: >>> d = { 'foo' : f , 'foo2' : 12 } >>> print ( yaml . safe_dump ( d )) foo : ! yamlable / com . yamlable . example . Foo { a : 1 , b : hello } foo2 : 12 In addition, the object directly offers the dump_yaml (dumping to file) / dumps_yaml (dumping to string) convenience methods, and the class directly offers the load_yaml (load from file) / loads_yaml (load from string) convenience methods. See PyYaml documentation for the various formatting arguments that you can use, they are the same than in the yaml.dump method. For example: >>> print ( f . dumps_yaml ( default_flow_style = False )) ! yamlable / com . yamlable . example . Foo a : 1 b : hello See Usage for other possibilities of yamlable .","title":"Usage"},{"location":"#main-features-benefits","text":"Add yaml-ability to any class easily through inheritance without metaclass (as opposed to YamlObject ) and without knowledge of internal PyYaml loader/dumper logic. Write codecs to support several types at a time with YamlCodec If you absolutely wish to use PyYaml's YamlObject for some reason, you can use YamlObject2 as an alternative to YamlAble . But it comes with the metaclass, like YamlObject .","title":"Main features / benefits"},{"location":"#see-also","text":"PyYaml documentation","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-yamlable","title":"Want to contribute ?"},{"location":"changelog/","text":"Changelog \u00b6 1.0.3 - packaging improvements \u00b6 packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #10 1.0.2 - pyproject.toml \u00b6 Added pyproject.toml . 1.0.1 - added __version__ attribute \u00b6 Added __version__ pkg-level attribute. 1.0.0 - Compliance with PyYaml 5.1 and de-facto 1.0.0 \u00b6 this version has been out and stable for long enough to be considered a good 1.0.0 PyYaml 5.1 added some breaking changes. We now comply with them while still supporting the old versions. Fixed #8 . 0.7.1 - minor fix \u00b6 Fixed the file opening mode in dump_yaml method when a file path is provided as argument. 0.7.0 - Abstract class definition and checks have been simplified \u00b6 It should now be easier to define an abstract yaml-able class for several object types. Deprecated NONE_IGNORE_CHECKS . Fixes #7 0.6.0 - YamlAble does not provide a constructor anymore \u00b6 Fixes #6 . 0.5.0 - Python 2.7 support \u00b6 Fixes #5 0.4.0 - YamlCodec completed + dunder methods \u00b6 YamlCodec completed (fixes #4 ): - YamlCodec.decode_yamlable renamed decode and YamlCodec.encode_yamlable renamed encode - added some checks in YamlCodec.encode to help users implement to_yaml_dict correctly - fixed bug in register_with_pyyaml : the wrong decoding method was registered - YamlCodec.create_from_yaml_dict renamed from_yaml_dict for consistency - added tests and usage documentation Renamed internal AbstractYamlObject methods with dunder (fixes #3 ): - from_yaml_dict becomes __from_yaml_dict__ - and to_yaml_dict become __to_yaml_dict__ Legacy names will remain supported for a while, added a tet to check that. 0.3.1 - minor error message improvement \u00b6 Filled yaml_info docstring. fixed class decoding so that it is robust to errors happening with faulty classes. This fixes #2 improved error message when decoding failed. 0.3.0 - safe parameter \u00b6 Added the safe parameter to all dumping and loading methods dump_yaml , dumps_yaml , load_yaml , loads_yaml . 0.2.0 - Added default implementation \u00b6 By default to_yaml_dict returns vars(self) and from_yaml_dict returns cls(**dct) . Fixes #1 0.1.0 - First public version \u00b6 Initial fork from private repository","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#103-packaging-improvements","text":"packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #10","title":"1.0.3 - packaging improvements"},{"location":"changelog/#102-pyprojecttoml","text":"Added pyproject.toml .","title":"1.0.2 - pyproject.toml"},{"location":"changelog/#101-added-__version__-attribute","text":"Added __version__ pkg-level attribute.","title":"1.0.1 - added __version__ attribute"},{"location":"changelog/#100-compliance-with-pyyaml-51-and-de-facto-100","text":"this version has been out and stable for long enough to be considered a good 1.0.0 PyYaml 5.1 added some breaking changes. We now comply with them while still supporting the old versions. Fixed #8 .","title":"1.0.0 - Compliance with PyYaml 5.1 and de-facto 1.0.0"},{"location":"changelog/#071-minor-fix","text":"Fixed the file opening mode in dump_yaml method when a file path is provided as argument.","title":"0.7.1 - minor fix"},{"location":"changelog/#070-abstract-class-definition-and-checks-have-been-simplified","text":"It should now be easier to define an abstract yaml-able class for several object types. Deprecated NONE_IGNORE_CHECKS . Fixes #7","title":"0.7.0 - Abstract class definition and checks have been simplified"},{"location":"changelog/#060-yamlable-does-not-provide-a-constructor-anymore","text":"Fixes #6 .","title":"0.6.0 - YamlAble does not provide a constructor anymore"},{"location":"changelog/#050-python-27-support","text":"Fixes #5","title":"0.5.0 - Python 2.7 support"},{"location":"changelog/#040-yamlcodec-completed-dunder-methods","text":"YamlCodec completed (fixes #4 ): - YamlCodec.decode_yamlable renamed decode and YamlCodec.encode_yamlable renamed encode - added some checks in YamlCodec.encode to help users implement to_yaml_dict correctly - fixed bug in register_with_pyyaml : the wrong decoding method was registered - YamlCodec.create_from_yaml_dict renamed from_yaml_dict for consistency - added tests and usage documentation Renamed internal AbstractYamlObject methods with dunder (fixes #3 ): - from_yaml_dict becomes __from_yaml_dict__ - and to_yaml_dict become __to_yaml_dict__ Legacy names will remain supported for a while, added a tet to check that.","title":"0.4.0 - YamlCodec completed + dunder methods"},{"location":"changelog/#031-minor-error-message-improvement","text":"Filled yaml_info docstring. fixed class decoding so that it is robust to errors happening with faulty classes. This fixes #2 improved error message when decoding failed.","title":"0.3.1 - minor error message improvement"},{"location":"changelog/#030-safe-parameter","text":"Added the safe parameter to all dumping and loading methods dump_yaml , dumps_yaml , load_yaml , loads_yaml .","title":"0.3.0 - safe parameter"},{"location":"changelog/#020-added-default-implementation","text":"By default to_yaml_dict returns vars(self) and from_yaml_dict returns cls(**dct) . Fixes #1","title":"0.2.0 - Added default implementation"},{"location":"changelog/#010-first-public-version","text":"Initial fork from private repository","title":"0.1.0 - First public version"},{"location":"long_description/","text":"yamlable \u00b6 A thin wrapper of PyYaml to convert Python objects to YAML and back. The documentation for users is available here: https://smarie.github.io/python-yamlable/ A readme for developers is available here: https://github.com/smarie/python-yamlable","title":"yamlable"},{"location":"long_description/#yamlable","text":"A thin wrapper of PyYaml to convert Python objects to YAML and back. The documentation for users is available here: https://smarie.github.io/python-yamlable/ A readme for developers is available here: https://github.com/smarie/python-yamlable","title":"yamlable"},{"location":"usage/","text":"Usage \u00b6 You have seen in the main page a small example to understand the concepts. Below we present other advanced usages. YamlCodec \u00b6 Sometimes you do not have the possibility to change the classes of the objects that you wish to encode/decode. In this case the solution is to write an independent codec, inheriting from YamlCodec . Once again this feature leverages the multi_constructor and multi_representer concepts available in the PyYaml internals, but with YamlCodec it becomes a bit easier to do. Let's assume that the following two classes are given and can not be modified: class Foo : def __init__ ( self , a , b ): self . a = a self . b = b def __eq__ ( self , other ): return vars ( self ) == vars ( other ) class Bar : def __init__ ( self , c ): self . c = c def __eq__ ( self , other ): return vars ( self ) == vars ( other ) Writing a codec is quite simple: first inherit from YamlCodec and fill get_yaml_prefix so that it returns the common prefix that all yaml objects encoded/decoded by this codec will use then fill the checkers: get_known_types to return all object types that can be encoded by this codec is_yaml_tag_supported to return True if a yaml tag (suffix) is supported by this codec for decoding. finally fill the encoder/decoder: from_yaml_dict to decode to_yaml_dict to encode The example below shows how it can be done: from yamlable import YamlCodec from typing import Type , Any , Iterable , Tuple # the yaml tag suffixes for the two classes foo_yaml = \"yaml.tests.Foo\" bar_yaml = \"yaml.tests.Bar\" # 2-way mappings between the types and the yaml tags types_to_yaml_tags = { Foo : foo_yaml , Bar : bar_yaml } yaml_tags_to_types = { foo_yaml : Foo , bar_yaml : Bar } class MyCodec ( YamlCodec ): @classmethod def get_yaml_prefix ( cls ): return \"!mycodec/\" # This is our root yaml tag # ---- @classmethod def get_known_types ( cls ) -> Iterable [ Type [ Any ]]: # return the list of types that we know how to encode return types_to_yaml_tags . keys () @classmethod def is_yaml_tag_supported ( cls , yaml_tag_suffix : str ) -> bool : # return True if the given yaml tag suffix is supported return yaml_tag_suffix in yaml_tags_to_types . keys () # ---- @classmethod def from_yaml_dict ( cls , yaml_tag_suffix : str , dct , ** kwargs ): # Create an object corresponding to the given tag, from the decoded dict typ = yaml_tags_to_types [ yaml_tag_suffix ] return typ ( ** dct ) @classmethod def to_yaml_dict ( cls , obj ) -> Tuple [ str , Any ]: # Encode the given object and also return the tag that it should have return types_to_yaml_tags [ type ( obj )], vars ( obj ) When you codec has been defined, it needs to be registerd before being usable. You can specify with which PyYaml Loaders/Dumpers it should be registered, or use the default (all): # register the codec MyCodec . register_with_pyyaml () Finally let's test that the codec works: from yaml import dump , load # instantiate f = Foo ( 1 , 'hello' ) fy = \"!mycodec/yaml.tests.Foo {a: 1, b: hello} \\n \" b = Bar ( 'what?' ) by = \"!mycodec/yaml.tests.Bar {c: 'what?'} \\n \" # dump assert dump ( f ) == fy assert dump ( b ) == by # load assert f == load ( fy ) assert b == load ( by )","title":"Usage details"},{"location":"usage/#usage","text":"You have seen in the main page a small example to understand the concepts. Below we present other advanced usages.","title":"Usage"},{"location":"usage/#yamlcodec","text":"Sometimes you do not have the possibility to change the classes of the objects that you wish to encode/decode. In this case the solution is to write an independent codec, inheriting from YamlCodec . Once again this feature leverages the multi_constructor and multi_representer concepts available in the PyYaml internals, but with YamlCodec it becomes a bit easier to do. Let's assume that the following two classes are given and can not be modified: class Foo : def __init__ ( self , a , b ): self . a = a self . b = b def __eq__ ( self , other ): return vars ( self ) == vars ( other ) class Bar : def __init__ ( self , c ): self . c = c def __eq__ ( self , other ): return vars ( self ) == vars ( other ) Writing a codec is quite simple: first inherit from YamlCodec and fill get_yaml_prefix so that it returns the common prefix that all yaml objects encoded/decoded by this codec will use then fill the checkers: get_known_types to return all object types that can be encoded by this codec is_yaml_tag_supported to return True if a yaml tag (suffix) is supported by this codec for decoding. finally fill the encoder/decoder: from_yaml_dict to decode to_yaml_dict to encode The example below shows how it can be done: from yamlable import YamlCodec from typing import Type , Any , Iterable , Tuple # the yaml tag suffixes for the two classes foo_yaml = \"yaml.tests.Foo\" bar_yaml = \"yaml.tests.Bar\" # 2-way mappings between the types and the yaml tags types_to_yaml_tags = { Foo : foo_yaml , Bar : bar_yaml } yaml_tags_to_types = { foo_yaml : Foo , bar_yaml : Bar } class MyCodec ( YamlCodec ): @classmethod def get_yaml_prefix ( cls ): return \"!mycodec/\" # This is our root yaml tag # ---- @classmethod def get_known_types ( cls ) -> Iterable [ Type [ Any ]]: # return the list of types that we know how to encode return types_to_yaml_tags . keys () @classmethod def is_yaml_tag_supported ( cls , yaml_tag_suffix : str ) -> bool : # return True if the given yaml tag suffix is supported return yaml_tag_suffix in yaml_tags_to_types . keys () # ---- @classmethod def from_yaml_dict ( cls , yaml_tag_suffix : str , dct , ** kwargs ): # Create an object corresponding to the given tag, from the decoded dict typ = yaml_tags_to_types [ yaml_tag_suffix ] return typ ( ** dct ) @classmethod def to_yaml_dict ( cls , obj ) -> Tuple [ str , Any ]: # Encode the given object and also return the tag that it should have return types_to_yaml_tags [ type ( obj )], vars ( obj ) When you codec has been defined, it needs to be registerd before being usable. You can specify with which PyYaml Loaders/Dumpers it should be registered, or use the default (all): # register the codec MyCodec . register_with_pyyaml () Finally let's test that the codec works: from yaml import dump , load # instantiate f = Foo ( 1 , 'hello' ) fy = \"!mycodec/yaml.tests.Foo {a: 1, b: hello} \\n \" b = Bar ( 'what?' ) by = \"!mycodec/yaml.tests.Bar {c: 'what?'} \\n \" # dump assert dump ( f ) == fy assert dump ( b ) == by # load assert f == load ( fy ) assert b == load ( by )","title":"YamlCodec"}]}